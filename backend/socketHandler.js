const jwt = require('jsonwebtoken'); // Keep for potential future auth middleware
const dotenv = require('dotenv');

dotenv.config(); // Load .env variables

// --- In-Memory Store for Connected Users ---
// Maps userId -> { socketId, role }
// IMPORTANT: Replace with Redis or similar in production for scalability.
const connectedUsers = new Map();

// Helper function to find socket ID by user ID
// Note: A user might have multiple connections (tabs/devices), this finds one.
const findSocketInfoByUserId = (userId) => {
  const userIdStr = String(userId); // Ensure string comparison
  // Iterate through the map to find the user
  for (const [id, info] of connectedUsers.entries()) {
      if (id === userIdStr) {
          return info; // Return { socketId, role }
      }
  }
  return null;
};

// --- Socket.IO Initializer Function ---
module.exports = function initializeSocket(io) {

    // --- Optional Authentication Middleware ---
    // io.use(async (socket, next) => {
    //   const token = socket.handshake.auth.token;
    //   if (!token) return next(new Error('Authentication error: No token provided'));
    //   try {
    //     const decoded = jwt.verify(token, process.env.JWT_SECRET);
    //     // Optional: Verify user exists in DB based on decoded.id
    //     socket.user = { id: String(decoded.id), role: decoded.role }; // Store user info on socket
    //     next();
    //   } catch (err) {
    //     console.error("Socket Auth Error:", err.message);
    //     next(new Error(`Authentication error: ${err.message}`));
    //   }
    // });

  // --- Connection Handler ---
  io.on('connection', (socket) => {
    console.log(`Socket connected: ${socket.id}`);
    let currentUserId = null; // Track the user ID associated with this specific socket

    // --- Event: User Joins ---
    // Client should emit 'join' with { userId, role } after connection & authentication
    socket.on('join', ({ userId, role }) => {
       // Basic validation
       if (!userId || !role) {
           console.warn(`Socket ${socket.id}: Invalid 'join' event received. Missing userId or role.`);
           socket.emit('error', { message: "Invalid join data. 'userId' and 'role' are required." }); // Notify client
           return;
       }

       currentUserId = String(userId); // Store user ID for this socket connection
       console.log(`User joined: ID=${currentUserId}, Role=${role}, Socket=${socket.id}`);

       // Store user info mapped by userId (overwrite if same user reconnects on different socket)
        const userInfo = { socketId: socket.id, role };
       connectedUsers.set(currentUserId, userInfo);

       // Join a room specific to the user ID (for direct messages/notifications)
       socket.join(currentUserId); // Use string representation for room name
        console.log(`Socket ${socket.id} joined user room: ${currentUserId}`);

       // Admins also join a general 'admin_room' for broadcasts
       if (role === 'admin') {
           socket.join('admin_room');
           console.log(`Admin ${currentUserId} (Socket ${socket.id}) joined admin_room`);
       }

       // Optional: Emit confirmation back to the user
        socket.emit('joined', { userId: currentUserId, room: currentUserId });

       // Optional: Broadcast presence to admins (if needed)
       // io.to('admin_room').emit('user_online', { userId: currentUserId, role });
    });


    // --- Event: Send Message ---
    socket.on('sendMessage', async ({ senderId, senderName, recipientId, text, missionId }) => { // Added missionId if applicable
        if (!currentUserId || String(senderId) !== currentUserId) {
            console.warn(`Auth mismatch/Not Joined: Socket ${socket.id} (User: ${currentUserId}) tried to send as ${senderId}. Ignoring.`);
            socket.emit('messageError', { message: 'Authentication mismatch or user not properly joined.' });
            return;
         }
         if (!recipientId || !text || typeof text !== 'string' || text.trim().length === 0) {
            console.warn(`Socket ${socket.id}: Invalid 'sendMessage' event. Missing recipientId or empty text.`);
            socket.emit('messageError', { message: 'Recipient and non-empty text are required.' });
            return;
        }

      const trimmedText = text.trim();
      console.log(`Message from ${currentUserId} (${senderName || 'N/A'}) to ${recipientId}: ${trimmedText.substring(0, 50)}...`);

      const messageData = {
        // id: Use DB auto-increment or UUID generated by DB/backend
        senderId: currentUserId,
        senderName: senderName || `User ${currentUserId}`, // Fallback sender name
        recipientId: String(recipientId),
        text: trimmedText,
        mission_id: missionId || null, // Include missionId if provided
        timestamp: new Date(), // Use backend timestamp
      };

       // --- Persist Message to Database ---
       try {
           const [result] = await pool.query('INSERT INTO messages SET ?', messageData);
           messageData.id = result.insertId; // Add the generated ID to the data
           console.log(`Message from ${currentUserId} to ${recipientId} saved to DB with ID: ${messageData.id}.`);

           // --- Message Routing via Socket.IO ---
            const targetUserIdStr = String(recipientId);
            let targetSocketInfo = null;

           if (targetUserIdStr === 'admin') { // Special case for sending to all admins
                console.log(`Broadcasting message ID ${messageData.id} to admin_room`);
                // Exclude the sender if they are also an admin to avoid self-messages via room
                if (connectedUsers.get(currentUserId)?.role !== 'admin') {
                    io.to('admin_room').emit('receiveMessage', messageData);
                } else {
                    // If sender is admin, send to room but exclude sender's socket
                    socket.to('admin_room').emit('receiveMessage', messageData);
                }
                 // Also potentially notify offline admins via push notifications
           } else {
                // Direct message to a specific user ID
                targetSocketInfo = findSocketInfoByUserId(targetUserIdStr);
                if (targetSocketInfo) {
                    console.log(`Emitting direct message ID ${messageData.id} to user ${targetUserIdStr} via socket ${targetSocketInfo.socketId}`);
                    // Send specifically to that user's room
                    io.to(targetUserIdStr).emit('receiveMessage', messageData);
                } else {
                    console.log(`Recipient ${targetUserIdStr} not currently connected. Message saved to DB.`);
                    // TODO: Handle offline messages (trigger push notification)
                    // triggerPushNotification(targetUserIdStr, messageData);
                }
            }

           // --- Send Confirmation Back to Sender --- (Optional)
           // Client usually handles this optimistically, but confirmation ensures DB save & routing attempt.
            socket.emit('messageSentConfirmation', { tempId: /* client-temp-id if sent */ null, ...messageData });

       } catch (dbError) {
           console.error(`Failed to save message from ${currentUserId} to ${recipientId} in DB:`, dbError);
           socket.emit('messageError', { message: 'Failed to send message. Please try again.' });
       }
    });

    // --- Event: Typing Indicator ---
    socket.on('typing', ({ senderId, recipientId, isTyping }) => {
        if (!currentUserId || String(senderId) !== currentUserId) {
             console.warn(`Auth mismatch/Not Joined: Socket ${socket.id} (User: ${currentUserId}) tried to send typing indicator as ${senderId}. Ignoring.`);
            return;
        }
        if (typeof isTyping !== 'boolean' || !recipientId) {
             console.warn(`Socket ${socket.id}: Invalid 'typing' event payload.`);
            return;
        }

        // console.log(`Typing indicator: Sender=${currentUserId}, Recipient=${recipientId}, IsTyping=${isTyping}`);

        const typingData = { senderId: currentUserId, recipientId: String(recipientId), isTyping };
        const targetUserIdStr = String(recipientId);

        // --- Typing Indicator Routing ---
        if (targetUserIdStr === 'admin') {
             // Broadcast to admin room, excluding the sender
             socket.to('admin_room').emit('typing', typingData);
        } else {
            // Direct indicator to a specific user's room
            // No need to find socket ID, just emit to the room name (user ID)
            io.to(targetUserIdStr).emit('typing', typingData);
        }
    });


    // --- Function to Send Notifications Programmatically ---
    const sendNotification = async (targetUserId, notificationData) => {
         const targetUserIdStr = String(targetUserId);
         console.log(`Attempting to send notification to user ${targetUserIdStr}:`, notificationData);

         // Ensure required fields and add timestamp
         if (!notificationData || !notificationData.type || !notificationData.message) {
             console.error("Invalid notification data provided to sendNotification:", notificationData);
             return;
         }
         if (!notificationData.timestamp) notificationData.timestamp = new Date();

         // --- Persist Notification to DB ---
         let notificationId = null;
         let dbStatus = 'pending'; // Assume pending initially
         const targetSocketInfo = findSocketInfoByUserId(targetUserIdStr);

         if (targetSocketInfo) {
             dbStatus = 'sent'; // Mark as sent if user is connected
         }

         try {
             const notificationToSave = {
                 user_id: targetUserIdStr,
                 message: notificationData.message,
                 type: notificationData.type,
                 mission_id: notificationData.missionId || null,
                 report_id: notificationData.reportId || null,
                 read_status: 0, // 0 for unread
                 created_at: notificationData.timestamp,
                 // Add other relevant fields from notificationData if needed
             };
             const [result] = await pool.query('INSERT INTO notifications SET ?', notificationToSave);
             notificationId = result.insertId;
             notificationData.id = notificationId; // Add DB ID to the data being sent
             console.log(`Notification for user ${targetUserIdStr} saved to DB with ID: ${notificationId}, Status: ${dbStatus}.`);

         } catch (dbError) {
             console.error(`Failed to save notification for user ${targetUserIdStr} to DB:`, dbError);
             // Decide if you should still try to send the socket event even if DB save failed
         }


         // --- Send via Socket.IO if User is Connected ---
         if (targetSocketInfo) {
             console.log(`Sending notification ID ${notificationId} to user ${targetUserIdStr} via socket ${targetSocketInfo.socketId}`);
             io.to(targetUserIdStr).emit('notification', notificationData); // Emit to the user's room
             // Optionally update DB status to 'delivered' if confirmation is received from client?
         } else {
             console.log(`User ${targetUserIdStr} not connected. Notification saved as pending.`);
             // TODO: Trigger Push Notification Service if implemented
             // triggerPushNotification(targetUserIdStr, notificationData);
         }
     };

     // Attach the sendNotification function to the io instance if not already present
     if (!io.sendNotification) {
         io.sendNotification = sendNotification;
         console.log("sendNotification function attached to io instance.");
     }


    // --- Event: Disconnect ---
    socket.on('disconnect', (reason) => {
      console.log(`Socket disconnected: ${socket.id}, Reason: ${reason}`);
      if (currentUserId) {
          // Remove user from the map
           const userInfo = connectedUsers.get(currentUserId);
           // Only remove if the socket ID matches (prevents removing if user reconnected on different socket)
           if (userInfo && userInfo.socketId === socket.id) {
               connectedUsers.delete(currentUserId);
               console.log(`User disconnected: ID=${currentUserId}. Removed from connected users map.`);
                // Optional: Broadcast user offline status to admins
                // io.to('admin_room').emit('user_offline', { userId: currentUserId });
           } else {
               console.log(`User ${currentUserId} disconnected, but socket ID ${socket.id} didn't match stored ID ${userInfo?.socketId}. No removal.`);
           }
      }
      currentUserId = null; // Clear user ID for this socket instance

      // Optional: Emit updated user list/count if needed (might be noisy)
      // io.emit('userListUpdate', Array.from(connectedUsers.keys())); // Send array of connected user IDs
    });

     // --- Error Handling ---
     socket.on('error', (error) => {
         console.error(`Socket Error (ID: ${socket.id}, User: ${currentUserId}):`, error);
         // Optionally disconnect the socket on critical errors
         // socket.disconnect();
     });

  });

   console.log("Socket.IO server initialized and connection handlers attached.");
};
